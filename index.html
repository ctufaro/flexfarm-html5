<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Flex Farm â€“ Whimsy Harvest</title>
  <style>
    :root {
      color-scheme: light;
      font-family: "Trebuchet MS", "Comic Sans MS", system-ui, sans-serif;
      --sky: #bfe9ff;
      --grass: #84d27d;
      --grass-dark: #6bb867;
      --soil: #b5754e;
      --soil-dark: #8d5637;
      --accent: #ffcf5c;
      --panel: rgba(255, 255, 255, 0.85);
      --ink: #2a2a2a;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      background: linear-gradient(180deg, var(--sky) 0%, #e8f6ff 45%, #fdf6e8 100%);
      color: var(--ink);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    body.playable main {
      grid-template-columns: 1fr;
    }

    body.playable .panel {
      display: none;
    }

    header {
      padding: 16px 24px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 12px;
    }

    header h1 {
      font-size: 1.5rem;
      margin: 0;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    header h1 span {
      font-size: 1.1rem;
      background: var(--accent);
      padding: 4px 10px;
      border-radius: 999px;
    }

    .hud {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
    }

    .hud .pill {
      background: var(--panel);
      padding: 6px 12px;
      border-radius: 999px;
      font-weight: 600;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.08);
    }

    main {
      flex: 1;
      display: grid;
      grid-template-columns: minmax(0, 1fr) minmax(260px, 320px);
      gap: 18px;
      padding: 0 24px 24px;
      align-items: stretch;
    }

    .play-area {
      position: relative;
      background: linear-gradient(180deg, #ffffff 0%, #f5ffef 100%);
      border-radius: 24px;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.15);
      overflow: hidden;
      min-height: 520px;
      display: flex;
      align-items: stretch;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .panel {
      background: var(--panel);
      border-radius: 20px;
      padding: 18px;
      box-shadow: 0 14px 30px rgba(0, 0, 0, 0.12);
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .panel h2 {
      margin: 0;
      font-size: 1.1rem;
    }

    .panel p {
      margin: 0;
      line-height: 1.4;
    }

    .legend {
      display: grid;
      gap: 10px;
      font-size: 0.95rem;
    }

    .legend span {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      display: inline-block;
    }

    .btn-row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 10px 16px;
      background: #2a2a2a;
      color: #fff;
      font-weight: 600;
      cursor: pointer;
    }

    button.secondary {
      background: #ffffff;
      color: #2a2a2a;
      border: 2px solid #2a2a2a;
    }

    button.toggle {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 14px;
      font-size: 0.95rem;
    }

    button.toggle span {
      font-size: 0.9rem;
    }

    .toast {
      position: absolute;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.9);
      padding: 10px 18px;
      border-radius: 999px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.18);
      font-weight: 600;
      opacity: 0;
      transition: opacity 0.25s ease, transform 0.25s ease;
      pointer-events: none;
    }

    .toast.show {
      opacity: 1;
      transform: translate(-50%, -4px);
    }

    .splash {
      position: absolute;
      inset: 0;
      background: linear-gradient(140deg, rgba(255, 255, 255, 0.92), rgba(255, 244, 208, 0.95));
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 24px;
      gap: 16px;
    }

    .splash .logo {
      font-size: clamp(2.2rem, 4vw, 3.2rem);
      font-weight: 800;
      letter-spacing: 0.04em;
      margin: 0;
      padding: 12px 28px;
      border-radius: 999px;
      background: #ffffff;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
      animation: bounce 1.6s ease-in-out infinite;
    }

    .splash .cta {
      font-size: 1.1rem;
      font-weight: 600;
      margin: 0;
    }

    .splash .hint {
      font-size: 0.95rem;
      opacity: 0.8;
      margin: 0;
    }

    @keyframes bounce {
      0%,
      100% {
        transform: translateY(0);
      }
      50% {
        transform: translateY(-14px);
      }
    }

    .asset-panel {
      background: rgba(255, 255, 255, 0.65);
      border-radius: 16px;
      padding: 14px;
      font-size: 0.9rem;
      line-height: 1.4;
      border: 1px dashed rgba(0, 0, 0, 0.1);
    }

    .asset-panel code {
      background: rgba(0, 0, 0, 0.05);
      padding: 2px 6px;
      border-radius: 8px;
      display: inline-block;
      margin-top: 4px;
    }

    @media (max-width: 900px) {
      main {
        grid-template-columns: 1fr;
      }

      .play-area {
        min-height: 460px;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Flex Farm <span>Whimsy Harvest</span></h1>
    <div class="hud">
      <div class="pill">Harvested: <strong id="stat-harvested">0</strong></div>
      <div class="pill">Combo: <strong id="stat-combo">0</strong>x</div>
      <button class="toggle secondary" id="sound-toggle"><span>ðŸ”Š</span> Sound: On</button>
      <button class="toggle secondary" id="music-toggle"><span>ðŸŽµ</span> Music: On</button>
    </div>
  </header>

  <main>
    <section class="play-area">
      <canvas id="game-canvas" width="960" height="640"></canvas>
      <div class="toast" id="toast">Yay!</div>
      <div class="splash" id="splash">
        <h2 class="logo">Whimsy Harvest</h2>
        <p class="cta">Click to play</p>
        <p class="hint">Tap to enable sound + music.</p>
      </div>
    </section>

    <aside class="panel">
      <h2>How it works</h2>
      <p>Click crops to pull them up. Each crop you harvest pops a little sparkle and refreshes somewhere new.</p>
      <div class="legend">
        <span><span class="dot" style="background: #f9a65a;"></span> Carrot pops (+1)</span>
        <span><span class="dot" style="background: #f26d6d;"></span> Tomato pops (+2)</span>
        <span><span class="dot" style="background: #7cc576;"></span> Lettuce pops (+1)</span>
        <span><span class="dot" style="background: #ffd166;"></span> Golden beet (combo bonus)</span>
      </div>
      <p>Keep an eye out for the golden beet to boost your combo meter!</p>
      <div class="asset-panel">
        <strong>Asset placeholders</strong>
        <p>Swap these file paths with your real audio + image assets:</p>
        <p>Music: <code>assets/music/relaxing-loop.mp3</code></p>
        <p>SFX: <code>assets/sfx/harvest-pop.mp3</code>, <code>assets/sfx/reveal-poof.mp3</code></p>
        <p>Images: <code>assets/items/carrot.png</code>, <code>assets/items/tomato.png</code>, <code>assets/items/lettuce.png</code>, <code>assets/items/golden-beet.png</code>, <code>assets/items/harvest-pop.png</code></p>
        <p>Recommended sizes: field art <code>960Ã—640</code>, crops <code>96Ã—96</code> (transparent PNG).</p>
      </div>
      <div class="btn-row">
        <button id="reset-btn" class="secondary">Reset Field</button>
      </div>
    </aside>
  </main>

  <script>
    const canvas = document.getElementById("game-canvas");
    const ctx = canvas.getContext("2d");
    const toast = document.getElementById("toast");
    const splash = document.getElementById("splash");
    const resetBtn = document.getElementById("reset-btn");
    const statHarvested = document.getElementById("stat-harvested");
    const statCombo = document.getElementById("stat-combo");
    const soundToggle = document.getElementById("sound-toggle");
    const musicToggle = document.getElementById("music-toggle");

    const urlParams = new URLSearchParams(window.location.search);
    const isPlayable = urlParams.has("playable");
    if (isPlayable) {
      document.body.classList.add("playable");
    }

    const state = {
      crops: [],
      particles: [],
      reveals: [],
      harvested: 0,
      combo: 0,
      showSplash: true,
      tutorialMode: false,
      lastHarvestTime: 0,
      hoveredCrop: null,
      soundEnabled: true,
      musicEnabled: true,
      audioReady: false,
    };

    const assets = {
      music: {
        background: "assets/music/relaxing-loop.mp3",
      },
      sfx: {
        harvest: "assets/sfx/harvest-pop.mp3",
        reveal: "assets/sfx/reveal-poof.mp3",
      },
      images: {
        Carrot: "assets/items/carrot.png",
        Tomato: "assets/items/tomato.png",
        Lettuce: "assets/items/lettuce.png",
        "Golden Beet": "assets/items/golden-beet.png",
        reveal: "assets/items/harvest-pop.png",
      },
    };

    const audio = {
      music: null,
      sfx: {},
    };

    const imageCache = {};

    const cropTypes = [
      {
        name: "Carrot",
        color: "#f9a65a",
        stem: "#6fbf73",
        value: 1,
        weight: 4,
      },
      {
        name: "Tomato",
        color: "#f26d6d",
        stem: "#6fbf73",
        value: 2,
        weight: 3,
      },
      {
        name: "Lettuce",
        color: "#7cc576",
        stem: "#4a9c5d",
        value: 1,
        weight: 3,
      },
      {
        name: "Golden Beet",
        color: "#ffd166",
        stem: "#9c7b29",
        value: 3,
        weight: 1,
        golden: true,
      },
    ];

    const field = {
      width: canvas.width,
      height: canvas.height,
      center: { x: canvas.width / 2, y: canvas.height / 2 },
    };

    const ensureAudioReady = () => {
      if (state.audioReady) {
        return;
      }
      state.audioReady = true;
      audio.music = new Audio(assets.music.background);
      audio.music.loop = true;
      audio.music.volume = 0.35;
      audio.sfx.harvest = new Audio(assets.sfx.harvest);
      audio.sfx.harvest.volume = 0.6;
      audio.sfx.reveal = new Audio(assets.sfx.reveal);
      audio.sfx.reveal.volume = 0.7;
      if (state.musicEnabled) {
        audio.music.play().catch(() => {});
      }
    };

    const playSfx = (soundKey) => {
      if (!state.audioReady || !state.soundEnabled) {
        return;
      }
      const source = audio.sfx[soundKey];
      if (!source) {
        return;
      }
      const clone = source.cloneNode();
      clone.volume = source.volume;
      clone.play().catch(() => {});
    };

    const toggleSound = () => {
      state.soundEnabled = !state.soundEnabled;
      soundToggle.textContent = state.soundEnabled ? "ðŸ”Š Sound: On" : "ðŸ”ˆ Sound: Off";
    };

    const toggleMusic = () => {
      state.musicEnabled = !state.musicEnabled;
      musicToggle.textContent = state.musicEnabled ? "ðŸŽµ Music: On" : "ðŸŽµ Music: Off";
      if (!state.audioReady) {
        return;
      }
      if (state.musicEnabled) {
        audio.music.play().catch(() => {});
      } else {
        audio.music.pause();
      }
    };

    const rngPick = (list) => {
      const total = list.reduce((sum, item) => sum + item.weight, 0);
      let roll = Math.random() * total;
      return list.find((item) => {
        roll -= item.weight;
        return roll <= 0;
      });
    };

    const showToast = (message) => {
      toast.textContent = message;
      toast.classList.add("show");
      setTimeout(() => toast.classList.remove("show"), 1100);
    };

    const spawnCrop = () => {
      const type = rngPick(cropTypes);
      const margin = 80;
      const crop = {
        id: Math.random().toString(36).slice(2),
        type,
        x: margin + Math.random() * (field.width - margin * 2),
        y: margin + Math.random() * (field.height - margin * 2),
        size: 18 + Math.random() * 10,
        bobOffset: Math.random() * Math.PI * 2,
      };
      state.crops.push(crop);
    };

    const resetField = () => {
      state.crops = [];
      state.particles = [];
      state.reveals = [];
      for (let i = 0; i < 18; i += 1) {
        spawnCrop();
      }
      state.harvested = 0;
      state.combo = 0;
      updateStats();
    };

    const updateStats = () => {
      statHarvested.textContent = state.harvested;
      statCombo.textContent = state.combo;
    };

    const createParticles = (x, y, color) => {
      for (let i = 0; i < 12; i += 1) {
        state.particles.push({
          x,
          y,
          vx: (Math.random() - 0.5) * 4,
          vy: (Math.random() - 0.8) * 4,
          life: 40 + Math.random() * 20,
          color,
        });
      }
    };

    const createDirtPoof = (x, y) => {
      for (let i = 0; i < 16; i += 1) {
        state.particles.push({
          x,
          y,
          vx: (Math.random() - 0.5) * 5,
          vy: (Math.random() - 0.8) * 5,
          life: 45 + Math.random() * 20,
          color: "rgba(141, 86, 55, 0.9)",
        });
      }
    };

    const getItemImage = (type) => {
      if (imageCache[type.name]) {
        return imageCache[type.name];
      }
      const image = new Image();
      image.src = assets.images[type.name];
      imageCache[type.name] = image;
      return image;
    };

    const drawBackground = () => {
      const skyHeight = field.height * 0.32;
      const rowHeight = 46;

      ctx.fillStyle = "#bfe9ff";
      ctx.fillRect(0, 0, field.width, field.height);

      const skyGradient = ctx.createLinearGradient(0, 0, 0, skyHeight);
      skyGradient.addColorStop(0, "#bfe9ff");
      skyGradient.addColorStop(1, "#eaf8ff");
      ctx.fillStyle = skyGradient;
      ctx.fillRect(0, 0, field.width, skyHeight);

      ctx.fillStyle = "rgba(255, 255, 255, 0.75)";
      ctx.beginPath();
      ctx.ellipse(160, 80, 90, 34, 0, 0, Math.PI * 2);
      ctx.ellipse(250, 85, 70, 30, 0, 0, Math.PI * 2);
      ctx.ellipse(360, 78, 80, 32, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
      ctx.beginPath();
      ctx.ellipse(620, 70, 95, 36, 0, 0, Math.PI * 2);
      ctx.ellipse(720, 90, 70, 28, 0, 0, Math.PI * 2);
      ctx.ellipse(810, 72, 80, 30, 0, 0, Math.PI * 2);
      ctx.fill();

      const fieldGradient = ctx.createLinearGradient(0, skyHeight, 0, field.height);
      fieldGradient.addColorStop(0, "#9fe28f");
      fieldGradient.addColorStop(1, "#7cc576");
      ctx.fillStyle = fieldGradient;
      ctx.fillRect(0, skyHeight, field.width, field.height - skyHeight);

      for (let i = 0; i < 12; i += 1) {
        const y = skyHeight + i * rowHeight;
        ctx.fillStyle = i % 2 === 0 ? "#7bbd69" : "#8acf74";
        ctx.fillRect(0, y, field.width, rowHeight);
        ctx.fillStyle = "rgba(255, 255, 255, 0.08)";
        ctx.fillRect(0, y + rowHeight * 0.1, field.width, rowHeight * 0.18);
      }

      ctx.fillStyle = "rgba(255, 255, 255, 0.2)";
      ctx.beginPath();
      ctx.ellipse(220, 210, 110, 42, 0, 0, Math.PI * 2);
      ctx.ellipse(700, 240, 130, 50, 0, 0, Math.PI * 2);
      ctx.fill();
    };

    const drawCrop = (crop, time) => {
      const bob = Math.sin(time / 500 + crop.bobOffset) * 2;
      const highlight = state.hoveredCrop && state.hoveredCrop.id === crop.id;
      const soilY = crop.y + crop.size + 10;

      ctx.fillStyle = "#9b5d3b";
      ctx.beginPath();
      ctx.ellipse(crop.x, soilY, crop.size * 1.2, crop.size * 0.6, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = crop.type.stem;
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(crop.x, crop.y - crop.size * 0.4 + bob);
      ctx.lineTo(crop.x, crop.y - crop.size * 1.2 + bob);
      ctx.stroke();

      ctx.fillStyle = crop.type.stem;
      ctx.beginPath();
      ctx.ellipse(crop.x - 6, crop.y - crop.size * 1.35 + bob, 10, 5, -0.4, 0, Math.PI * 2);
      ctx.ellipse(crop.x + 6, crop.y - crop.size * 1.35 + bob, 10, 5, 0.4, 0, Math.PI * 2);
      ctx.fill();

      if (highlight) {
        ctx.strokeStyle = "rgba(255, 255, 255, 0.9)";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(crop.x, crop.y + bob, crop.size * 1.4, 0, Math.PI * 2);
        ctx.stroke();
      }
    };

    const drawParticles = () => {
      state.particles.forEach((particle) => {
        ctx.fillStyle = particle.color;
        ctx.globalAlpha = Math.max(0, particle.life / 60);
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      });
    };

    const drawReveal = (reveal, time) => {
      const progress = Math.min((time - reveal.start) / reveal.duration, 1);
      const easeOut = 1 - Math.pow(1 - progress, 3);
      const scale = 0.6 + easeOut * 0.8;
      const glow = Math.sin(progress * Math.PI);
      const image = reveal.image;
      const size = reveal.size * scale;

      ctx.save();
      ctx.globalAlpha = 1 - progress * 0.2;
      ctx.fillStyle = `rgba(255, 255, 255, ${0.5 * glow})`;
      ctx.beginPath();
      ctx.arc(reveal.x, reveal.y, reveal.size * (1.2 + glow * 0.6), 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = `rgba(255, 204, 92, ${0.8 * (1 - progress)})`;
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(reveal.x, reveal.y, reveal.size * (1 + progress * 1.2), 0, Math.PI * 2);
      ctx.stroke();

      if (image && image.complete && image.naturalWidth) {
        ctx.drawImage(image, reveal.x - size / 2, reveal.y - size / 2, size, size);
      } else {
        ctx.fillStyle = reveal.type.color;
        ctx.beginPath();
        ctx.ellipse(reveal.x, reveal.y, size * 0.55, size * 0.7, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "rgba(255, 255, 255, 0.85)";
        ctx.font = `${Math.max(14, size * 0.5)}px "Trebuchet MS", sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("?", reveal.x, reveal.y);
      }

      ctx.restore();
    };

    const updateParticles = () => {
      state.particles = state.particles.filter((particle) => particle.life > 0);
      state.particles.forEach((particle) => {
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.vy += 0.08;
        particle.life -= 1;
      });
    };

    const render = (time) => {
      drawBackground();
      state.crops.forEach((crop) => drawCrop(crop, time));
      state.reveals.forEach((reveal) => drawReveal(reveal, time));
      drawParticles();
      updateParticles();
      state.reveals = state.reveals.filter((reveal) => time - reveal.start < reveal.duration);
      requestAnimationFrame(render);
    };

    const harvestCrop = (crop) => {
      const now = Date.now();
      const timeSince = now - state.lastHarvestTime;
      state.lastHarvestTime = now;
      state.combo = timeSince < 1500 ? Math.min(state.combo + 1, 9) : 0;
      const comboBonus = crop.type.golden ? 2 : 0;
      const points = crop.type.value + comboBonus;
      state.harvested += points;
      updateStats();
      createDirtPoof(crop.x, crop.y + crop.size * 0.8);
      createParticles(crop.x, crop.y - crop.size * 0.2, crop.type.color);
      state.reveals.push({
        x: crop.x,
        y: crop.y - crop.size * 0.2,
        type: crop.type,
        start: performance.now(),
        duration: 650,
        size: 72,
        image: imageCache.reveal || getItemImage({ name: "reveal" }),
      });
      showToast(`${crop.type.name} +${points}`);
      playSfx("harvest");
      setTimeout(() => {
        playSfx("reveal");
      }, 120);
      state.crops = state.crops.filter((item) => item.id !== crop.id);
      setTimeout(() => {
        spawnCrop();
      }, 500);
    };

    const getCropAt = (x, y) => {
      return state.crops.find((crop) => {
        const dx = x - crop.x;
        const dy = y - crop.y;
        return Math.sqrt(dx * dx + dy * dy) < crop.size * 1.2;
      });
    };

    const scalePoint = (event) => {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      return {
        x: (event.clientX - rect.left) * scaleX,
        y: (event.clientY - rect.top) * scaleY,
      };
    };

    canvas.addEventListener("pointermove", (event) => {
      const point = scalePoint(event);
      state.hoveredCrop = getCropAt(point.x, point.y);
    });

    canvas.addEventListener("pointerleave", () => {
      state.hoveredCrop = null;
    });

    canvas.addEventListener("pointerdown", (event) => {
      if (state.showSplash) {
        return;
      }
      ensureAudioReady();
      const point = scalePoint(event);
      const crop = getCropAt(point.x, point.y);
      if (crop) {
        harvestCrop(crop);
      }
    });

    splash.addEventListener("pointerdown", () => {
      if (!state.showSplash) {
        return;
      }
      state.showSplash = false;
      splash.style.display = "none";
      ensureAudioReady();
      showToast("Click crops to pull them up!");
    });

    resetBtn.addEventListener("click", () => {
      resetField();
      showToast("Fresh soil, fresh crops!");
    });

    soundToggle.addEventListener("click", () => {
      toggleSound();
      ensureAudioReady();
    });

    musicToggle.addEventListener("click", () => {
      toggleMusic();
      ensureAudioReady();
    });

    resetField();
    requestAnimationFrame(render);
  </script>
</body>
</html>
